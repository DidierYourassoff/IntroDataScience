---
title: "Come on"
author: "Didier Yourassoff"
date: "(`r format(Sys.time(), '%d %B, %Y')`)"
output:
  github_document:
      toc: true
bibliography: "DYreferences.bib"
---

This report uses the [R programming language](https://cran.r-project.org/doc/FAQ/R-FAQ.html) [@R] and the following [R libraries](https://r-pkgs.org/intro.html) [@tidyverse;@knitr].

```{r, message=FALSE, warning=FALSE}
#Import libraries
library(tidyverse)
library(dplyr)
library(knitr)
library(ggplot2)
library("stringr")
```

***

# Introduction

My friends like to describe me as a gourmet. I love to eat, to cook.
Food is an integral part of my life, as I am sure it is of yours. Life
made me discover Indian food a little more deeply at the beginning of
this year. I have been interested in it ever since. So much so that
while searching for data for my data practical, I came across a data set
listing lots of Indian dishes. Bingo! No need to continue the research.
I have my raw material for my work. The subject interests me and at the
same time I'm going to learn more about this spicy cuisine. Let's go!

So I'm going to work with the [Indian Food
101](https://www.kaggle.com/datasets/nehaprabhavalkar/indian-food-101)
data set assembled by Neha Prabhavalkar. I have retrieved the data from
[Kaggle](www.https://www.kaggle.com/datasets), a site known for listing
a large number of datasets. According to the description provided with
the data set [Indian Food
101](https://www.kaggle.com/datasets/nehaprabhavalkar/indian-food-101),
it contains information about 255 traditional Indian dishes: including
the ingredients required to make them, the place of origin of the dishes
and many other elements. To learn more, let's take a look at the data!

***

# Let's explore the data

First, I will import the data and display the first rows of the table.

```{r, warning=FALSE, message=FALSE}
#Import data from github repository
IndianFood_df <- read_csv(url("https://raw.githubusercontent.com/DidierYourassoff/IntroDataScience/main/indian_food.csv"))
#Display the first lines of the table
head(IndianFood_df) %>% kable()
```

From the first lines, and the names of the columns, I can already see
that I have a column for the name of each dish, one for the necessary
ingredients, one for the diet, one for the preparation time, one for the
cooking time, one for the course of meal, one for the flavor profile,
one for the state of origin and finally one for the region of origin of
each dish.

Also, as it stands, for the ingredients column, I see that there are
several ingredients listed in one cell, while the other columns contain
one piece of information per cell. For example, there is only one region
or preparation time for each dish. I will come back to this later.

Now let's look at the last few rows of the table.

```{r, warning=FALSE, message=FALSE}
#Display the last lines of the table
tail(IndianFood_df) %>% kable()
```

The last lines do not give much more information than the first lines. I
see, for example, concerning the flavor profile, a new value, "spicy",
where I had only "sweet" in the first lines. Similarly, concerning the
course column, a new value "main course", where I had only "dessert".

However, when I look at these last lines, I discover cells with the
value (-1). According to the description provided with the data set,
this is a convention to notify cells that have no assigned values.
Preferring to work with NA's, I will replace each value (-1) with a NA
in the data set.

Here is what the last rows of the table look like now.

```{r, warning=FALSE, message=FALSE}
#Replacing (-1) with NA
IndianFood_df <- na_if(IndianFood_df, -1)
#Display the last lines of the table
tail(IndianFood_df) %>% kable()
```

Now let's take a broader perspective by starting with the `str()`
function.

```{r, warning=FALSE, message=FALSE}
#Display the structure of the data set
str(IndianFood_df)
```
Here I see that the data set represents 255 rows and 9 columns. Among
the nine columns, there are two of type numeric (num) and seven of type
character (chr). Then, I can get a synthetic overview thanks to the
`summary()` function.

```{r, warning=FALSE, message=FALSE}
#Display a synthetic overview
summary(IndianFood_df)
```
What do we have this time? I see several interesting pieces of
information for the prep_time and cook_time columns, namely the mean,
the median. Also for prep_time I have 30 NA's, which means that the
preparation time is not filled in for 30 dishes; similarly, I have 28
NA's for cook_time, which means that the cooking time is not filled in
for 28 dishes.

For the rest of the columns, I only retain one length information being
255 for all. This echoes the 255 rows that the table has as indicated by
the `str()` function above. That said, I can get more information from
the `str()` and `summary()` functions by turning the character columns
into factor's. This is what I get. 

Here is the structure with the type conversions of the columns.

```{r, warning=FALSE, message=FALSE}
#Convert character columns as factor
IndianFood_df <- IndianFood_df %>%
  mutate_if(is.character, as.factor)
#Display the structure of the data set
str(IndianFood_df)
```
And the output of the `summary()` function.

```{r, warning=FALSE, message=FALSE}
#Display a synthetic overview
summary(IndianFood_df)
```
I will consider one column after another. First, using the `str()` 
function, I see that the name column contains "255 levels", which means
that there are 255 unique names, or one name for each dish. This
corroborates the description of the data set given in the introduction.

Similarly, the function `str()` indicates that the ingredients column
contains "252 levels", which means that there are 252 combinations of
ingredients. And since there are 255 dishes referenced for 252
ingredient combinations, this means that some dishes have the same
ingredient combination. I can verify this by looking at the output of
the `summary()` function, which indeed shows two occurrences for each of
the following combinations:

*"Arbi ke patte, sesame seeds, gur, bengal gram flour, imli"
*"Chhena, sugar, ghee"
*"Gram flour, ghee, sugar".

Then, for the diet column, I note from the `str()` function that there
are "2 levels". And the output of the `summary()` function explains the
two types of meals they refer to, namely "non-vegetarian" and
"vegetarian".

I won't dwell on the prep_time and cook_time columns here, since they
were not affected by the column type conversion.

For the flavor profile, the `str()` function displays "4 levels", which
I find in the output of `summary()`, namely "bitter", "sour", "spicy",
"sweet". I also note that there are 28 NA's, which means that 28 dishes
have no value assigned for the flavor profile.

Then, for the course column, the `str()` function returns "4 levels",
and `summary()` describes "dessert", "main course", "snack", "starter".

For the state column, the `str()` function returns "24 levels". That is,
24 different states. On the other hand, the `summary()` function makes
explicit only the five largest states in terms of number of associated
dishes; the others appear as "(Other)" in addition to the NA's. Still,
24 is a possible and consistent number given that India has 29 states
and seven union territories [@Dandona2017].

Finally, for the original region column, I get from the `str()` function
"6 levels", which are summarized by the `summary()` function as follows:
"Central", "East", "North", "North East", "South", "West", and NA's.

Que faire maintenant avec toute ses données que nous venons d'explorer? C'est l'objet de la section suivant

# Questions to be answer et hypothesis

À partir de ce jeux de donnée, je me demande si le fait d'être un
dessert plutôt qu'un main course ou encore un snack a un une influence
sur les ingrédients utilisés, et aussi sur combien d'ingrédients sont
utilisés.

No need to do prediction here, cf. la leçon 7 sur github de Moran

## hypothesis
H0 : le course of meal du plat n'a aucune impact sur le ... (nbr
ingrédient, ingrédients utilisés)

HA : le course of meal du plat a un impact sur le NOMBRE ingrédient,
QUELS SONT LES ingrédients utilisés,

### Here I select the data I need

Afin de répondre à mon hypothèse, l'ensemble des données du data set n'est pas forcément pertinente. En effet considérons le graphique ci-dessus.

```{r, warning=FALSE, message=FALSE}
IndianFood_df %>%
  ggplot(aes(x = course, fill=course)) + 
  geom_bar()  +
  facet_wrap(~ diet)
```
Sur ce graphique, j'affiche, à partir de tout le data set, le nombre de plat étant qualifiés en fonction de leur statut de dessert, main course, snack, ou starter. De plus, l'ensemble des plats est séparés entre selon le fait d'être végétarian ou non. Ce que je vois toute de suite, c'est qu'il y a une grande majorité de plat végétarian. Je propose de nous concentrer uniquement sur ces plats là pour la suite.
À noter qu'il n'y a pas de starter végétarian, c'est à dire que je vais travailler avec le course of meal comme étant un factor à trois niveau ducoup. Je supprimerais le niveau de starter au moment de la sélection des données, et je supprimerais également les niveau de factor nul liés à la colonne ingredients et name.

Je vais conserver la colone liées au nom et au ingrédients, car elles permette respectivement d'identifier les observations et les ingrédients sont un éléments central de mon investigations.

La colonne diet n'est plus pertinente étant donnée que je vais travailler unqieument avec des repas végétariens. 

Je ne vais pas conserver les prep_time et cook_time, ni la colonne liées aux indications géographiques de régions et d'état. Il s'agit de faire un choix cohérent par rapport à l'hypothèse que je me donne. 

Voici ce que ça implique au niveau du code.  

```{r, warning=FALSE, message=FALSE}
#selection des données 
Selectedfood <- IndianFood_df %>%
  #filter vegetarian meal
  filter(diet=="vegetarian") %>%
  #select les colonnes qui nous intéressent 
  select(name, course, ingredients)
#Removing unused factor level in the data set 
Selectedfood <- droplevels.data.frame(Selectedfood)
```
Et la nouvelle structure.

```{r, warning=FALSE, message=FALSE}
#Display the structure of the data set
str(Selectedfood)
```
Il nous reste donc pour travailler 226 recettes comme l'indique les "226 levels" de la colonne name en sortie de la fonction ´str()´. Revenons à l'hypothèse. Celle-ci se divise en deux parties. Je vais commencer à traiter de la première partie, liée au nombre d'ingrédient des recettes.

## Combien d'ingrédient par plat 

ça ne vous aura pas échappé vous qui lisez ce rapport, en l'état actuelle nous n'avons pas de colonne qui renseigne de manière directe le nombre d'ingrédient pour chaque recette. Cela dit, comme mentionnée plus haut, la colonne des ingrédients rassemble l'ensemble des ingrédients de chaque  recette dans une même cellule. Et, si on regarde bien, on peut voir que chaque ingrédient dans une même cellule.

Ainsi, si je réussi à compter pour chaque recette le nombre de virgule présent dans la cellule des ingrédients, je peux en déduire le nombre d'ingrédient qu'elle compte: il s'agit d'une nombre de virgule en plus d'une unité étant qu'une virgule sépare deux ingrédients. Allons-y!

```{r, warning=FALSE, message=FALSE}
NbrIngPerDish <- Selectedfood %>%
  #create a new colun called NbrIng et calculate how many ingredients
  mutate(Selectedfood, NbrIng = (str_count(ingredients, ",")+1))
```
Voici les premières lignes, soit les recettes comptant le plus d'ingrédients en haut

```{r, warning=FALSE, message=FALSE}
  NbrIngPerDish%>%
  #put celui qui a le plus grand nombre tout en haut du tableau
  arrange(desc(NbrIng)) %>%
  head()%>%
  kable()
```
Je note ici que le nombre maximum d'ingrédient pour une recette est de 10 et c'est un dessert. Appelons maintenant  la fonction `summary()` pour plus de détails.

```{r, warning=FALSE, message=FALSE}
summary(NbrIngPerDish)
```
La sortie de la fonction `summary()` me donnent accès au nombre de recette en fonction de course of meal d'une part. en chiffre, 39 recettes de snacks, 85 dessert et 102 main course. Notons que nous avions déjà 85 dessert dans l'ensemble du data set au tout début. En effet, psa de dessert à la viande car nous travaillons dans cette partie qu'avec les recette végétarienne et nous avons le même nombre de dessert. m'me chose pour les snacks, pas de sncak non végétarien. et c'est immédiat à vérifier si on regarde le premier grapihque qui affichait végé d'un côté et pas végé de l'autre un peu plus haut. 

Maintenant on veut voir si, les dessert demandent en général plus d'ingrédient que les mains course ou peut être que les snacks. Voici un graphique.

```{r, warning=FALSE, message=FALSE}

# ça, ce qui a en dessous à adapter pour pouvoir  ajouter la sample size sous le violon et comme ça on peut se rendre compte de la différence dans la taille des échantillons. Je dois aussi faire le test statistique et c'est pas mal ensuite. 
# sample size
sample_size = NbrIngPerDish %>%
  group_by(course) %>%
  summarise(num=n())

# Plot
NbrIngPerDish %>%
  left_join(sample_size) %>%
  mutate(myaxis = paste0(course, "\n", "n=", num)) %>%
  ggplot(aes(x=myaxis, y=NbrIng, fill=course)) +
    geom_violin() +
    ggtitle("A boxplot with jitter") +
    xlab("mess cas do")
```

Boxplot hides the sample size of each group, show it with annotation or box width. J'ai fait ça. 

Selon la première partie de l'hypothèse H0, le fait d'être un dessert ou un main course ou un snack n'a pas d'impact sur le nombre d'ingrédient à utiliser. À partir du graphique ci-dessus, j'observe que les main course et les snack ont en majorité 5 aliments là où s'il s'agit de dessert, ce serait un peu moins 4. 

Faisons un peu de statistique pour savoir ce qu'il en est 

qu'est-ce que j'ai moi dans ce cas en réalité: 2
types of variables

1 Independent var (predictor) categorical nominal
1 Dependent   var (outcome) quantitative discret

ASSUMPTIONS POUR ANOVA 
independence of observation => yes

Homogeneity of variance ==> ? je veux voir si je trouve quelque chose pour ça, sinon je fais Kruskal-Wallis
Of these tests, the most common assessment for homogeneity of variance is Levene’s test.  The Levene’s test uses an F-test to test the null hypothesis that the variance is equal across groups.  A p value less than .05 indicates a violation of the assumption. If a violation occurs, it is likely that conducting the non-parametric equivalent of the analysis is more appropriate.
Levene's Test for Homogeneity of Variance (center = median)
       Df F value    Pr(>F)    
group   2  18.762 2.944e-08 ***
      223 
      
ducoup c'est baisé, on fait le kruskal-Wallis

```{r, warning=FALSE, message=FALSE}
#leveneTest(NbrIng ~ course, data = NbrIngPerDish)
library(car)
Test_homogenvar = leveneTest(NbrIng ~ course, data = NbrIngPerDish)
Test_homogenvar
```

Normality of data, quand tu vois le graph en dessous, les données n'ont pas l'air distribuée normallement, mais en même temps le sample est plus de 30, donc je pourrais quand même y aller. ==> mouais


```{r, warning=FALSE, message=FALSE}
NbrIngPerDish %>%
  ggplot(aes(x=NbrIng)) +
  geom_histogram()

```
ducoup c'est mort pour l'anova à cause de la violation de la normality distribution(même si sample size est grand), et violation de homogeneiti of variance (test de levene) tout ça veut dire qu'on va ==> Krus

```{r, warning=FALSE, message=FALSE}
kruskal.test(NbrIng ~ course, data = NbrIngPerDish)

```
We can then say there are significant differences between the treatment groups, being the course, dessert, snack, and the number of ingredient(p-value < 0.001).

Nous pouvons ainsi rejeter l'hypotèse h0 pour la première partie ce qui signifie que le fait d'être main course, desserto ou snack a un impact sur le nombre d'ingrédient en moyenne.


ANOVA is used when you want to find out if there are differences between several groups.
Assumptions of this test:
    Population distribution is normal
    Samples are random and independent
    Homogeneity of sample variance
    
Qu'en est-il de la deuxième partie? Est-ce que il y a des ingrédients différents utilisés en fonction des main course, dessert ou snack ?

## Quel ingrédients est le plus utilisé en de manière générale
(si ça marche, facetting suivant les courses, ou alors juste à la main faire trois sous tableau)

pour tarvaillé sur les ingrédients utilisé en général, il nous faut rendre tidy la cellue des ingrédients. C'est à dire travaillé sur les données pour obtenir une information par cellule uniquement. Or nous savons qu'il y a au maximum 10 ingrédient par recette. Donc la première étape est de séparer la colonne des ingrédients, et de l'étaler sur 10 colonnes si on veut. Pour se faire je dois utiliser la fonction ´separate()´qui demande un vecteur pour nommer les nouvelles collones qui vont apparaître. 

```{r, warning=FALSE, message=FALSE}
#working on ingredient seperatly
#To separate ingredients column
NewColNames <- c("ing1","ing2","ing3","ing4","ing5","ing6","ing7","ing8","ing9","ing10")
NbrDishwtIng_wide <- NbrIngPerDish %>%
  #Separe ingredient colum
  separate(ingredients, NewColNames, sep=",")
```
là je dois déterminer demain ce que j'affiche en terme de structure, je pense j'affiche la structure et la head. Mais peut être que je met la head avant. Voir comment j'ai fait plus haut.

```{r, warning=FALSE, message=FALSE}
str(NbrDishwtIng_wide)
```

```{r, warning=FALSE, message=FALSE}
head(NbrDishwtIng_wide) %>% kable()
```

Mainteant, pour travialler au mieux, je vais transformer ce tableau qui désormais plutôt large en quelque chose de long format. Tidy je pourrais dire

```{r, warning=FALSE, message=FALSE}
NbrDishwtIng_long <- NbrDishwtIng_wide %>%
  pivot_longer(ing1:ing10, names_to = "IngRank", values_to = "Ing")
```

Voici la structure ainsi obtenue

```{r, warning=FALSE, message=FALSE}
str(NbrDishwtIng_long)
```
Comme plutôt je vais transformer les colonnes character en facteur poru pouvoir tirer partie u maximum de la fonction summary. Voici ce que j'obtiens grâce à celle-ci.

```{r, warning=FALSE, message=FALSE}
NbrDishwtIng_long <- NbrDishwtIng_long %>%
  mutate_if(is.character, as.factor)

summary(NbrDishwtIng_long)
```
Ici, je vois toute de suite un nombre de NA augmenté étant donné les cases vides qui corresponde au recette qui avait moins de 10 ingrédients. Pour rappel, le maximum est de 10, et il n'y a qu'une seul recette qui a autant d'ingrédient comme indiqué plus haut dans la partie précédente (NbrIngPerDish). 
Je propose de nettoyer un peu ces données pour y voir plus clair. 

```{r, warning=FALSE, message=FALSE}
NbrDishwtIng_clean <- NbrDishwtIng_long %>%
  #remove NA'S rows
  filter(!is.na(Ing)) %>%
  #remove IngRank columns I don't use
  select(-IngRank)
```

Et voici la structure des données une fois nettoyées. Puis, j'affiche la sortie de la fonction ´summary()´.

```{r, warning=FALSE, message=FALSE}
str(NbrDishwtIng_clean)
summary(NbrDishwtIng_clean)
```
Je fini donc avec un tableau ici de 4 colonnes pour 987 lignes selon la fonction ´str()´. Et grâce à la sortie de la fonction ´summary()´, je peux noter que les cinq ingrédients les plus utilisés sont le sugar, ghee, curry leaves, garam masala, ginger.

Toutefois ici c'est par rapport à l'ensemble, qu'en est-il suivant les types à savoir dessert, plat principale et snack. Voici les top 5 des ingrédients les plus présents dans un dessert, puis dans un main course et finalement dans un snack.

```{r, warning=FALSE, message=FALSE}
# displaying things according to what they are main course, dessert, or whatever
Topslicebycountry <- NbrDishwtIng_clean %>%
  group_by(course, Ing) %>%
  summarise(sum=n()) %>%
  arrange(desc(sum)) %>%
  slice(c(1:5))

Topslicebycountry

Topslicebycountry %>%
  ggplot(aes(x = Ing, y= sum, fill=Ing)) + 
  geom_col()  +
  facet_wrap(~course) + 
  scale_x_discrete(guide = guide_axis(angle = 90))
```
écrire la conclusion et clean ce qui y a au-dessus. Gere en mode, dire qu'on se retrouve avec 12 douze ingrédients phares.
<!-- If you wanna draw a horizontal line, you have to type in three times * and have free line before and after. -->

# References
